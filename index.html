<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Trabalho 2 - Claudio</title>
        <link href="style.css" rel="stylesheet" type="text/css">
    </head>

    <body style="background-color: grey;">
        <script type="text/javascript">
            var totalPoints = 0;
            var shots = 5;
        </script>
        <div id="wrapper">
            <canvas class="webgl" id="canvas" width="1420" height="720"></canvas>
            <canvas class="hud" id="hud" width="1420" height="720"></canvas>
        </div>

        <script src="https://twgljs.org/dist/4.x/twgl-full.min.js"></script>
        <script src="https://webglfundamentals.org/webgl/resources/3d-math.js"></script>
        <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
        <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
        <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>

        <script type="text/javascript" src="controlpoints.js"></script>
        <script type="text/javascript" src="camera.js"></script>
        
        <script id="sky_vs" type="x-shader/x-fragment">
            attribute vec4 a_position;
            varying vec4 v_position;
            void main() {
                v_position = a_position;
                gl_Position = a_position;
                gl_Position.z = 1.0;
            }
        </script>
        <script id="sky_fs" type="x-shader/x-fragment">
            precision mediump float;
            
            uniform samplerCube u_skybox;
            uniform mat4 u_viewDirectionProjectionInverse;
            
            varying vec4 v_position;
            void main() {
                vec4 t = u_viewDirectionProjectionInverse * v_position;
                gl_FragColor = textureCube(u_skybox, normalize(t.xyz / t.w));
            }
        </script>
        <script id="cube_vs" type="x-shader/x-fragment">
            attribute vec4 a_position;
            attribute vec4 a_color;
            attribute vec3 a_normal;

            uniform mat4 u_matrix;
            uniform vec3 u_LightPosition;

            varying vec4 v_color;

            void main() {
                gl_Position = u_matrix * a_position;

                // Lighting calculations
                vec3 normal = normalize(mat3(u_matrix) * a_normal);
                vec3 lightDirection = normalize(u_LightPosition - a_position.xyz);
                float lightIntensity = max(dot(normal, lightDirection), 0.0);

                v_color = vec4(0.5, 0.5, 1.0, 0.0) * lightIntensity;
            }
        </script>
        <script id="cube_fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec4 v_color;

            void main() {
                gl_FragColor = vec4(v_color);
            }
        </script>
        <script id="ball_vs" type="x-shader/x-fragment">
            attribute vec4 a_position;
            attribute vec4 a_color;
            attribute vec2 a_texcoord; // Add a new attribute for texture coordinates

            uniform mat4 u_matrix;
            
            varying vec4 v_color;
            varying vec2 v_texcoord; // Add a varying variable for texture coordinates

            void main() {
                // Multiply the position by the matrix.
                gl_Position = u_matrix * a_position;

                // Pass the color to the fragment shader.
                v_color = a_color;

                // Pass the texture coordinates to the fragment shader.
                v_texcoord = a_texcoord;
            }
        </script>
        <script id="ball_fs" type="x-shader/x-fragment">
            precision mediump float;
        
            // Passed in from the vertex shader.
            varying vec4 v_color;
            varying vec2 v_texcoord; // Varying variable for texture coordinates
        
            uniform vec4 u_colorMult;
            uniform sampler2D u_texture; // Add a uniform for the texture
        
            // Define the light position as a uniform
            uniform vec3 u_lightPosition;
        
            void main() {
                // Sample the texture using the texture coordinates.
                vec4 textureColor = texture2D(u_texture, v_texcoord);
        
                // Calculate the vector from the fragment to the light position
                vec3 lightVector = normalize(u_lightPosition - gl_FragCoord.xyz);
        
                // Calculate the diffuse lighting using the dot product of the light vector and the surface normal
                float diffuse = max(dot(lightVector, normalize(vec3(0.0, 0.0, 1.0))), 5.0);
        
                // Set the base color
                vec3 baseColor = vec3(1, 1, 1);
        
                // Apply the lighting to the fragment color
                vec3 finalColor = baseColor * diffuse * v_color.rgb + 1.0;
        
                // Apply the texture color to the fragment color
                gl_FragColor = vec4(finalColor, textureColor.a);
            }
        </script>
        <script id="envmap-vertex-shader" type="x-shader/x-fragment">
            attribute vec4 a_position;
            attribute vec3 a_normal;
            
            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_world;
            
            varying vec3 v_worldPosition;
            varying vec3 v_worldNormal;
            
            void main() {
                // Multiply the position by the matrix.
                gl_Position = u_projection * u_view * u_world * a_position;
                
                // send the view position to the fragment shader
                v_worldPosition = (u_world * a_position).xyz;
                
                // orient the normals and pass to the fragment shader
                v_worldNormal = mat3(u_world) * a_normal;
            }
        </script>
        <script id="envmap-fragment-shader" type="x-shader/x-fragment">
            precision highp float;
            
            // Passed in from the vertex shader.
            varying vec3 v_worldPosition;
            varying vec3 v_worldNormal;
            
            // The texture.
            uniform samplerCube u_texture;
            
            // The position of the camera
            uniform vec3 u_worldCameraPosition;
            
            void main() {
                vec3 worldNormal = normalize(v_worldNormal);
                vec3 eyeToSurfaceDir = normalize(v_worldPosition - u_worldCameraPosition);
                vec3 direction = reflect(eyeToSurfaceDir,worldNormal);
                
                gl_FragColor = textureCube(u_texture, direction);
            }
        </script>

        <script type="module" src="skybox.js"></script>
        <script type="module" src="cube.js"></script>
        <script type="module" src="ground.js"></script>
        <script type="module" src="hud.js"></script>
    </body>
    </html>